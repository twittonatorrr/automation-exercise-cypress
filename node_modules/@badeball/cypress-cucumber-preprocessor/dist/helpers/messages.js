"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTimestamp = createTimestamp;
exports.duration = duration;
exports.durationToNanoseconds = durationToNanoseconds;
exports.removeDuplicatedStepDefinitions = removeDuplicatedStepDefinitions;
exports.removeUnusedDefinitions = removeUnusedDefinitions;
exports.orderMessages = orderMessages;
const assertions_1 = require("./assertions");
function createTimestamp() {
    const now = new Date().getTime();
    const seconds = Math.floor(now / 1000);
    const nanos = (now - seconds * 1000) * 1000000;
    return {
        seconds,
        nanos,
    };
}
function duration(start, end) {
    return {
        seconds: end.seconds - start.seconds,
        nanos: end.nanos - start.nanos,
    };
}
function durationToNanoseconds(duration) {
    return Math.floor(duration.seconds * 1000000000 + duration.nanos);
}
function removeDuplicatedStepDefinitions(envelopes) {
    var _a;
    const seenDefinitions = [];
    const findSeenStepDefinition = (stepDefinition) => seenDefinitions.find((seenDefinition) => {
        var _a, _b;
        return (seenDefinition.uri === stepDefinition.sourceReference.uri &&
            seenDefinition.line === ((_a = stepDefinition.sourceReference.location) === null || _a === void 0 ? void 0 : _a.line) &&
            seenDefinition.column ===
                ((_b = stepDefinition.sourceReference.location) === null || _b === void 0 ? void 0 : _b.column));
    });
    for (let i = 0; i < envelopes.length; i++) {
        const { stepDefinition } = envelopes[i];
        if (stepDefinition &&
            stepDefinition.sourceReference.uri !== "not available") {
            const seenDefinition = findSeenStepDefinition(stepDefinition);
            if (seenDefinition) {
                // Remove this from the stack.
                envelopes.splice(i, 1);
                // Make sure we iterate over the "next".
                i--;
                // Find TestCase's in which this is used.
                for (let x = i; x < envelopes.length; x++) {
                    const { testCase } = envelopes[x];
                    if (testCase) {
                        for (const testStep of testCase.testSteps) {
                            // Replace ID's of spliced definition with ID of the prevously seen definition.
                            testStep.stepDefinitionIds = (_a = testStep.stepDefinitionIds) === null || _a === void 0 ? void 0 : _a.map((stepDefinitionId) => stepDefinitionId.replace(stepDefinition.id, seenDefinition.id));
                        }
                    }
                }
            }
            else {
                seenDefinitions.push({
                    id: stepDefinition.id,
                    uri: stepDefinition.sourceReference.uri,
                    line: stepDefinition.sourceReference.location.line,
                    column: stepDefinition.sourceReference.location.column,
                });
            }
        }
    }
}
function removeUnusedDefinitions(envelopes) {
    for (let i = 0; i < envelopes.length; i++) {
        const { stepDefinition } = envelopes[i];
        if (stepDefinition) {
            const isUsed = envelopes.some((envelope) => {
                var _a;
                return (_a = envelope.testCase) === null || _a === void 0 ? void 0 : _a.testSteps.some((testStep) => { var _a; return (_a = testStep.stepDefinitionIds) === null || _a === void 0 ? void 0 : _a.includes(stepDefinition.id); });
            });
            if (!isUsed) {
                // Remove this from the stack.
                envelopes.splice(i, 1);
                // Make sure we iterate over the "next".
                i--;
            }
        }
    }
}
/**
 * Some messages are emitted out-of-order, but not all. The messages below are the ones that need
 * additional sorting. The remaining messages are untouched.
 */
const MESSAGES_ORDER = [
    "meta",
    "source",
    "gherkinDocument",
    "pickle",
    "parameterType",
    "stepDefinition",
    "hook",
    "testRunStarted",
    "testCase",
];
function orderMessages(messages) {
    const toBeSorted = messages.map((message, i) => {
        const keys = Object.keys(message);
        (0, assertions_1.assert)(keys.length === 1, "Expected a message to have one, and only one, property");
        const [key] = keys;
        const primary = MESSAGES_ORDER.indexOf(key);
        return {
            primary: primary === -1 ? null : primary,
            secondary: i,
            message,
        };
    });
    return toBeSorted
        .sort((a, b) => {
        if (a.primary === null && b.primary === null) {
            return a.secondary - b.secondary;
        }
        else if (a.primary === null) {
            return 1; // b comes first,
        }
        else if (b.primary === null) {
            return -1; // a comes first.
        }
        else {
            const order = a.primary - b.primary;
            // To get stable sorting out of a non-stable sorting function.
            return order === 0 ? a.secondary - b.secondary : order;
        }
    })
        .map(({ message }) => message);
}
